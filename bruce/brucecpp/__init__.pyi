import numpy
from typing import ClassVar, overload

from . import stimulus

ACTUAL: PowerLaw
APPROXIMATED: PowerLaw
BOLTZMAN: SynapseMapping
CAT: Species
EXPONENTIAL: SynapseMapping
FIXED_MATLAB: NoiseType
FIXED_SEED: NoiseType
HIGH: FiberType
HUMAN_GLASSBERG_MOORE: Species
HUMAN_SHERA: Species
LOW: FiberType
MEDIUM: FiberType
NONE: SynapseMapping
ONES: NoiseType
RANDOM: NoiseType
SOFTPLUS: SynapseMapping

class Fiber:
    spont: float
    tabs: float
    trel: float
    type: FiberType
    def __init__(self, spont: float, tabs: float, trel: float, type: FiberType) -> None: ...

class FiberType:
    __members__: ClassVar[dict] = ...  # read-only
    HIGH: ClassVar[FiberType] = ...
    LOW: ClassVar[FiberType] = ...
    MEDIUM: ClassVar[FiberType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __and__(self, other: object) -> object: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> object: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, other: object) -> object: ...
    def __rand__(self, other: object) -> object: ...
    def __ror__(self, other: object) -> object: ...
    def __rxor__(self, other: object) -> object: ...
    def __xor__(self, other: object) -> object: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Neurogram:
    bin_width: float
    @overload
    def __init__(self, n_cf: int = ..., n_low: int = ..., n_med: int = ..., n_high: int = ...) -> None: ...
    @overload
    def __init__(self, cfs: list[float], n_low: int = ..., n_med: int = ..., n_high: int = ...) -> None: ...
    def create(self, sound_wave: stimulus.Stimulus, n_rep: int = ..., species: Species = ..., noise_type: NoiseType = ..., power_law: PowerLaw = ...) -> None: ...
    def get_cfs(self) -> list[float]: ...
    def get_fibers(self, cf_idx: int) -> list[Fiber]: ...
    def get_fine_timing(self) -> tuple[numpy.ndarray[numpy.float64], float]: ...
    def get_mean_timing(self) -> tuple[numpy.ndarray[numpy.float64], float]: ...
    def get_unfiltered_output(self) -> numpy.ndarray[numpy.float64]: ...

class NoiseType:
    __members__: ClassVar[dict] = ...  # read-only
    FIXED_MATLAB: ClassVar[NoiseType] = ...
    FIXED_SEED: ClassVar[NoiseType] = ...
    ONES: ClassVar[NoiseType] = ...
    RANDOM: ClassVar[NoiseType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __and__(self, other: object) -> object: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> object: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, other: object) -> object: ...
    def __rand__(self, other: object) -> object: ...
    def __ror__(self, other: object) -> object: ...
    def __rxor__(self, other: object) -> object: ...
    def __xor__(self, other: object) -> object: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PowerLaw:
    __members__: ClassVar[dict] = ...  # read-only
    ACTUAL: ClassVar[PowerLaw] = ...
    APPROXIMATED: ClassVar[PowerLaw] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __and__(self, other: object) -> object: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> object: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, other: object) -> object: ...
    def __rand__(self, other: object) -> object: ...
    def __ror__(self, other: object) -> object: ...
    def __rxor__(self, other: object) -> object: ...
    def __xor__(self, other: object) -> object: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Species:
    __members__: ClassVar[dict] = ...  # read-only
    CAT: ClassVar[Species] = ...
    HUMAN_GLASSBERG_MOORE: ClassVar[Species] = ...
    HUMAN_SHERA: ClassVar[Species] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __and__(self, other: object) -> object: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> object: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, other: object) -> object: ...
    def __rand__(self, other: object) -> object: ...
    def __ror__(self, other: object) -> object: ...
    def __rxor__(self, other: object) -> object: ...
    def __xor__(self, other: object) -> object: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SynapseMapping:
    __members__: ClassVar[dict] = ...  # read-only
    BOLTZMAN: ClassVar[SynapseMapping] = ...
    EXPONENTIAL: ClassVar[SynapseMapping] = ...
    NONE: ClassVar[SynapseMapping] = ...
    SOFTPLUS: ClassVar[SynapseMapping] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __and__(self, other: object) -> object: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> object: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __or__(self, other: object) -> object: ...
    def __rand__(self, other: object) -> object: ...
    def __ror__(self, other: object) -> object: ...
    def __rxor__(self, other: object) -> object: ...
    def __xor__(self, other: object) -> object: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SynapseOutput:
    def __init__(self, n_rep: int, n_timesteps: int) -> None: ...
    @property
    def mean_firing_rate(self) -> list[float]: ...
    @property
    def mean_relative_refractory_period(self) -> list[float]: ...
    @property
    def n_rep(self) -> int: ...
    @property
    def n_timesteps(self) -> int: ...
    @property
    def n_total_timesteps(self) -> int: ...
    @property
    def psth(self) -> list[float]: ...
    @property
    def redocking_time(self) -> list[float]: ...
    @property
    def spike_times(self) -> list[float]: ...
    @property
    def synaptic_output(self) -> list[float]: ...
    @property
    def variance_firing_rate(self) -> list[float]: ...

def inner_hair_cell(stimulus: stimulus.Stimulus, cf: float = ..., n_rep: int = ..., cohc: float = ..., cihc: float = ..., species: Species = ...) -> list[float]: ...
def map_to_synapse(ihc_output: list[float], spontaneous_firing_rate: float, characteristic_frequency: float, time_resolution: float, mapping_function: SynapseMapping = ...) -> list[float]: ...
def set_seed(arg0: int) -> None: ...
def synapse(amplitude_ihc: list[float], cf: float, n_rep: int, n_timesteps: int, time_resolution: float = ..., noise: NoiseType = ..., pla_impl: PowerLaw = ..., spontaneous_firing_rate: float = ..., abs_refractory_period: float = ..., rel_refractory_period: float = ..., calculate_stats: bool = ...) -> SynapseOutput: ...
